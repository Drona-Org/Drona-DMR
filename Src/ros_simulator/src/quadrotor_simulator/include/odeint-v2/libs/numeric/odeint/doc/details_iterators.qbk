[/============================================================================
  Boost.odeint

  Copyright (c) 2009-2012 Karsten Ahnert
  Copyright (c) 2009-2012 Mario Mulansky

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[section Iterators and Ranges]



odeint supports iterators that iterate along an approximate solution of an ordinary differential equation. Iterators offer you an alternative to the integrate functions. Furthermore, many of the standard algorithms in the C++ standard library and Boost.Range can be used with the odeint's iterators.

[import ../examples/const_step_iterator.cpp]

Four iterator types are provided. They are all single pass iterators. The first one is an iterator which solves the ode with constant step size. An example is 

[const_step_iterator_accumulate]

In this example all x-values of the solution are accumulated. Note, how
dereferencing the iterator gives the current state `x` of the ODE (the second
argument of the accumulate lambda). The iterator
itself does not occur directly in this example but it is generated by the
factory functions `make_const_step_iterator_begin` and
`make_const_step_iterator_end`. odeint also supports Boost.Range, that allows to write the above example in a more compact form with the factory function `make_const_step_range`:

[const_step_iterator_accumulate_range]

The second iterator type is also a iterator with const step size. But the value type of this iterator consists here of a pair of the time and the state of the solution of the ODE. An example is

[const_step_time_iterator_accumulate_range]

The factory functions are now `make_const_step_time_iterator_begin`, `make_const_step_time_iterator_end` and `make_const_step_time_range`.


[import ../examples/adaptive_iterator.cpp]

The other two iterator types are adaptive iterators which are completely
analogous to the const step iterators, but are based on adaptive stepper
routines and thus adjust the step size during the iteration. Examples are

[adaptive_iterator_accumulate_range]

[adaptive_time_iterator_accumulate_range]

Below we give some brief details about the iterators and their usage.

[section const_step_iterator]

* Definition: `const_step_iterator< Stepper , System >`
* `value_type` is `Stepper::state_type`
* `reference_type` is `Stepper::state_type const&`
* Factory functions
  * `make_const_step_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_const_step_iterator_end( stepper , system , state )`
  * `make_const_step_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the Stepper concept or the DenseOutputStepper concept.
* The value of `state` is the current state of the ODE during the iteration.

[endsect]

[section const_step_time_iterator]

* Definition: `const_step_time_iterator< Stepper , System >`
* `value_type` is `std::pair< Stepper::state_type , Stepper::time_type >`
* `reference_type` is `std::pair< Stepper::state_type const& , Stepper::time_type > const&`
* Factory functions
  * `make_const_step_time_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_const_step_time_iterator_end( stepper , system , state )`
  * `make_const_step_time_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the Stepper concept or the DenseOutputStepper concept.
* This stepper updates the value of `state`. The value of `state` is the current state of the ODE during the iteration.


[endsect]


[section adaptive_step_iterator]

* Definition: `adaptive_iterator< Stepper , System >`
* `value_type` is `Stepper::state_type`
* `reference_type` is `Stepper::state_type const&`
* Factory functions
  * `make_adaptive_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_adaptive_iterator_end( stepper , system , state )`
  * `make_adaptive_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the ControlledStepper concept or the DenseOutputStepper concept.
* For steppers fulfilling the ControlledStepper concept `state` is modified according to the current state of the ODE. For DenseOutputStepper the state is not modified due to performance optimizations, but the steppers itself.


[endsect]

[section adaptive_step_time_iterator]

* Definition: `adaptive_iterator< Stepper , System >`
* `value_type` is `std::pair< Stepper::state_type , Stepper::time_type >`
* `reference_type` is `std::pair< Stepper::state_type const& , Stepper::time_type > const&`
* Factory functions
  * `make_adaptive_time_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_adaptive_time_iterator_end( stepper , system , state )`
  * `make_adaptive_time_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the ControlledStepper concept or the DenseOutputStepper concept.
* For steppers fulfilling the ControlledStepper concept `state` is modified according to the current state of the ODE. For DenseOutputStepper the state is not modified due to performance optimizations, but the stepper itself.


[endsect]






[endsect]
